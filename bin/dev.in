#! /bin/bash

# prefix-related directories and other stuff from configuration
prefix=@prefix@
exec_prefix=@exec_prefix@
libdir=@libdir@
export DEV_VERSION=@PACKAGE_VERSION@

# get all of our paths
source $libdir/dev/paths.sh

# a few utility commands

dev_commands() {
  for dir in `echo $DEV_COMMAND_DIRS | tr : ' '`
  do
    for cmd in $dir/*
    do
      if [ -f $cmd -a -x $cmd ]
      then
        echo ${cmd##$dir/}
      fi
    done
  done
}

find_command() {
  command=$1
  for dir in `echo $DEV_COMMAND_DIRS | tr : ' '`
  do
    if [ -f $dir/$command -a -x $dir/$command ]
    then
      echo $dir/$command
      exit
    fi
  done
}

usage() {
  $CAT <<EOF
Usage: $0 [-h] [-v] command <command args>
This script consults environment variable DEV_PROJECT, which should
be a path to the project you're currently working on.

  -h: this message
  -v: show version

Available commands are:
EOF
  # lifted from quilt
  dev_commands | $SORT | $COLUMN | $COLUMN -t | $SED -e $'s/^/\t/'
  exit 1
}

# get down to work

# check that DEV_PROJECT is defined first of all
if [ "x$DEV_PROJECT" = "x" ]
then
  echo 'DEV_PROJECT is not defined!'
  exit
fi

# load the settings for the current project
for rc in $libdir/dev/defaults.sh $etcdir/devrc $HOME/.devrc $DEV_PROJECT/.devrc
do
  [ -f $rc ] && source $rc
done

# parse any args
while getopts "hv" flag
do
  case "$flag" in
    :|\?|h) usage; exit;;
    v) echo $0 'version' $DEV_VERSION; exit;;
  esac
done

# now pull any of that stuff off the command line
shift $(($OPTIND-1))
OPTIND=1

# if no command given, give usage
[ $# = 0 ] && usage

# figure out the path of the command
command="$1"
shift
cmd_path="`find_command $command`"
[ "$cmd_path" = "" ] && usage 

# source any utiity function libraries
for fns in $libdir/dev/functions.sh $DEV_PROJECT/lib/dev/functions.sh
do
  [ -f $fns ] && source $fns
done

# finally, execute the command
. $cmd_path
